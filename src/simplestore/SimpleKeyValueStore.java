package simplestore;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Stream;

/**
 * Store is a LinkedHashMap. I used it so that the order of values will remain when using reduce method.
 *
 * Namespace are generated by concatenating namespace and key.
 * At first I thought about making Map<String, Map<String, T>> as a store, but I have dropped
 * that idea since implementation started to feel a bit too complicated.
 *
 * To clone an object (in order to prevent value change from outside the map), it has to implement
 * @Serializable interface. If not, it will throw @NotSerializableException due the way I have implemented
 * cloning.
 */
public class SimpleKeyValueStore<T> implements KeyValueStore<T> {

    private Map<String, LinkedHashMap<String,T>> store = new LinkedHashMap<>();

    @Override
    public void put(String namespace, String key, T value) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {

        Class<?> aClass = value.getClass();
        Constructor<?> constructor = aClass.getConstructor();
        T o = (T) constructor.newInstance(value);

        if(!store.containsKey(namespace)){
            LinkedHashMap<String, T> namespaceMap = new LinkedHashMap<>();
            namespaceMap.put(key,o);
            store.put(namespace,namespaceMap);
        }else{
            LinkedHashMap<String, T> stringTLinkedHashMap = store.get(namespace);
            stringTLinkedHashMap.put(key,o);
            store.put(namespace,stringTLinkedHashMap);
        }
    }

    @Override
    public T get(String namespace, String key) {
        Map<String, T> namespaceMap = store.get(namespace);
        return namespaceMap.get(key);
    }

    @Override
    public boolean delete(String namespace, String key) {
        Map<String, T> namespaceMap = store.get(namespace);
        T remove = namespaceMap.remove(key);
        return remove != null;
    }

    public Stream<T> filter(String namespace, Predicate<? super T> predicate) {
        LinkedHashMap<String, T> stringTLinkedHashMap = store.get(namespace);
        return stringTLinkedHashMap.values().stream().filter(predicate);
    }

    public <R> Stream<R> map(String namespace, Function<? super T, ? extends R> mapper) {
        LinkedHashMap<String, T> stringTLinkedHashMap = store.get(namespace);
        return stringTLinkedHashMap.values().stream().map(mapper);
    }

    public T reduce(String namespace,T identity, BinaryOperator<T> accumulator) {
        LinkedHashMap<String, T> stringTLinkedHashMap = store.get(namespace);
        return stringTLinkedHashMap.values().stream().reduce(identity, accumulator);
    }

    public Optional<T> reduce(String namespace, BinaryOperator<T> accumulator) {
        LinkedHashMap<String, T> stringTLinkedHashMap = store.get(namespace);
        return stringTLinkedHashMap.values().stream().reduce(accumulator);
    }

    public <U> U reduce(String namespace, U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner) {
        LinkedHashMap<String, T> stringTLinkedHashMap = store.get(namespace);
        return stringTLinkedHashMap.values().stream().reduce(identity, accumulator, combiner);
    }
}
