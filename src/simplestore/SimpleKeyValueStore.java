package simplestore;

import java.io.*;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Stream;

/**
 * Store is a LinkedHashMap. I used it so that the order of values will remain when using reduce method.
 *
 * Namespace are generated by concatenating namespace and key.
 * At first I thought about making Map<String, Map<String, T>> as a store, but I have dropped
 * that idea since implementation started to feel a bit too complicated.
 *
 * To clone an object (in order to prevent value change from outside the map), it has to implement
 * @Serializable interface. If not, it will throw @NotSerializableException due the way I have implemented
 * cloning.
 */
public class SimpleKeyValueStore<T extends Serializable> implements KeyValueStore<T> {

    private Map<String, T> store = new LinkedHashMap<>();

    @Override
    public void put(String namespace, String key, T value) throws IOException, ClassNotFoundException {
        T newValue = this.clone(value);
        String namespaceWithKey = namespaceKeyJoiner(namespace, key);
        store.put(namespaceWithKey, newValue);
    }

    private String namespaceKeyJoiner(String namespace, String key) {
        return namespace + "." + key;
    }

    private T clone(T obj) throws IOException, ClassNotFoundException {
        byte[] bytes = objToByte(obj);
        return byteToObj(bytes);
    }

    private byte[] objToByte(T value) throws IOException {
        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
        ObjectOutputStream objStream = new ObjectOutputStream(byteStream);
        objStream.writeObject(value);
        return byteStream.toByteArray();
    }

    private T byteToObj(byte[] bytes) throws IOException, ClassNotFoundException {
        ByteArrayInputStream byteStream = new ByteArrayInputStream(bytes);
        ObjectInputStream objStream = new ObjectInputStream(byteStream);
        return (T) objStream.readObject();
    }

    @Override
    public T get(String namespace, String key) {
        return store.get(namespaceKeyJoiner(namespace, key));
    }

    @Override
    public boolean delete(String namespace, String key) {
        T remove = store.remove(namespaceKeyJoiner(namespace, key));
        return remove != null;
    }

    private LinkedHashMap<String,T> extractNamespace(String namespace){
        LinkedHashMap<String, T> certainNamespace = new LinkedHashMap<>();

        for (Map.Entry<String,T> entry : store.entrySet()) {
            if(entry.getKey().contains(namespace)){
                certainNamespace.put(entry.getKey(), entry.getValue());
            }
        }
        return certainNamespace;
    }

    public Stream<T> filter(String namespace, Predicate<? super T> predicate) {
        LinkedHashMap<String, T> stringTLinkedHashMap = extractNamespace(namespace);
        return stringTLinkedHashMap.values().stream().filter(predicate);
    }


    public <R> Stream<R> map(String namespace, Function<? super T, ? extends R> mapper) {
        LinkedHashMap<String, T> stringTLinkedHashMap = extractNamespace(namespace);
        return stringTLinkedHashMap.values().stream().map(mapper);
    }

    public T reduce(String namespace,T identity, BinaryOperator<T> accumulator) {
        LinkedHashMap<String, T> stringTLinkedHashMap = extractNamespace(namespace);
        return stringTLinkedHashMap.values().stream().reduce(identity, accumulator);
    }

    public Optional<T> reduce(String namespace, BinaryOperator<T> accumulator) {
        LinkedHashMap<String, T> stringTLinkedHashMap = extractNamespace(namespace);
        return stringTLinkedHashMap.values().stream().reduce(accumulator);
    }

    public <U> U reduce(String namespace, U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner) {
        LinkedHashMap<String, T> stringTLinkedHashMap = extractNamespace(namespace);
        return stringTLinkedHashMap.values().stream().reduce(identity, accumulator, combiner);
    }
}
